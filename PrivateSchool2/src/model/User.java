package model;

/**
 * Model of a User
 * <p>
 * A User has a {@link model.User#username username}, 
 * a {@link model.User#password password}, 
 * a {@link model.User#saltKey salt key}, 
 * a {@link model.User#id unique id} and 
 * a {@link model.User#type type}. 
 * <p>
 * Meant to be extended by concrete classes of users : 
 * {@link model.Headmaster Headmaster}, 
 * {@link model.Trainer Trainer}, 
 * {@link model.Student Student}
 *
 * @author Sakel
 * @version 1.0
 */
public abstract class User<T> {

    /**
     * unique identifier of a user [int(11) auto increment PK] 
     * <p>
     * If this is a new user, and not an existing one taken from 
     * the database, then id is allowed to not be instantiated since id
     * will be <b>auto generated by the database</b> once the new user is inserted
     * <p>
     * In the database the unique identifier is
     * propagated through foreign keys to student/trainer userid and from there to 
     * assignments_students, courses_students, courses_trainers tables that map
     * many to many relationships between tables assignments - students, 
     * courses - students, courses - trainers respectively
     */
    private int id;
    
    /**
     * The type of this user [enum('headmaster','trainer','student') not null]
     * <p>
     * Controls the access level of the user and directs queries to 
     * either students or trainers table 
     * (headmaster has no extra info, so no table)
     * <p>
     * For new users, type options are enforced by the use of
     * {@link model.Utils.UserType Enum Utils.UserType}
     * as expected parameter in the appropriate constructor
     */
    private String type;
    
    /**
     * The username of this user [varchar(50) not null]
     */
    private String username;
    
    /**
     * The hashed password of this user [varbinary not null]
     */
    private byte[] password;
    
    /**
     * The hashed salt key of this user [varbinary not null]
     */
    private byte[] saltKey;
    
    User(){}

    /**
     * Constructor for new users (no id yet)
     * 
     * @param type enum('headmaster','trainer','student') not null
     * @param username varchar(50) not null
     * @param password varbinary not null
     * @param saltKey varbinary not null
     */
    User(String type, String username, byte[] password, byte[] saltKey) {
        this.type = type;
        this.username = username;
        this.password = password;
        this.saltKey = saltKey;
    }
    
    /**
     * Constructor for existing users (with id)
     * 
     * @param id int(11) auto increment PK
     * @param type enum('headmaster','trainer','student') not null
     * @param username varchar(50) not null
     * @param password varbinary not null
     * @param saltKey varbinary not null
     */
    protected User(String type, String username, byte[] password, byte[] saltKey, int id) {
        this.id = id;
        this.type = type;
        this.username = username;
        this.password = password;
        this.saltKey = saltKey;
    }
    
    public abstract T factory(String type, String username, byte[] password, byte[] saltKey, Object[] args);
    
    public abstract T factory(String type, String username, byte[] password, byte[] saltKey, int id, Object[] args);

    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getUsername() {
        return username;
    }

    public byte[] getPassword() {
        return password;
    }

    public byte[] getSaltKey() {
        return saltKey;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(byte[] password) {
        this.password = password;
    }

    public void setSaltKey(byte[] saltKey) {
        this.saltKey = saltKey;
    }
    
    

}
